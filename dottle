#!/bin/sh

CONFIG_FILE="${CONFIG_FILE:-install.conf.yml}"
BASEDIR="$(cd "$(dirname "$0")" && pwd)"
cd "${BASEDIR}"

# color variables
ESC_SEQ="\033["
COL_RESET=$ESC_SEQ"0m"
COL_BLACK=$ESC_SEQ"0;30;01m"
COL_RED=$ESC_SEQ"0;31;01m"
COL_GREEN=$ESC_SEQ"0;32;01m"
COL_YELLOW=$ESC_SEQ"0;33;01m"
COL_BLUE=$ESC_SEQ"0;34;01m"
COL_MAGENTA=$ESC_SEQ"0;35;01m"
COL_CYAN=$ESC_SEQ"0;36;01m"
COL_WHITE=$ESC_SEQ"0;37;01m"

# Special print funcions
ok () {
    if [ ! -z "$1" ]; then
        printf "${COL_GREEN}[ok]${COL_RESET} %b\n" "$1"
    else
        printf "${COL_GREEN}[ok]${COL_RESET}"
    fi
}

warn () {
    printf "${COL_BLUE}[warning]${COL_RESET} %b\n" "$1"
}

error () {
    if [ ! -z "$1" ]; then
        printf "${COL_RED}[error]${COL_RESET} %b\n" "$1" 1>&2
    else
        printf "${COL_RED}[error]${COL_RESET}" 1>&2
    fi
}

debug () {
    if [ -n "$DEBUG" ]; then
        printf "$COL_MAGENTA[debug]$COL_RESET %b\n" "$1" 1>&2
    fi
}

running () {
    printf "$COL_YELLOW[running]$COL_RESET %b" "$1"
}

show_help () {
    cat << EOF
Usage: ./dottle [OPTIONS] COMMAND [ARGS]

Options:
- None for now

Commands and args:
- None for now
EOF
}

escape () {
    # Escape a string mainly for expand_vars
    debug "EXPAND: '$1'"
    printf '%s' "$1" | sed \
                        -e 's:^~/:'$HOME'/:' \
                        -e 's/\\\([^\$]\)/\\\\&/g' \
                        -e 's/"/\\"/g' \
                        -e 's/\\\$/\\\$/g'
}

expand_vars () {
    # Expand env vars in a string
    # if safe is set don't expand $VARS only the tilde
    eval printf '%s' "\"$(escape "$1")\""
}

get_level () {
    # Get indentation level
    printf '%s' "$1" | sed -e 's/[^ ].*$//' -e 's/    /X/' -e 's/[^X]//' | wc -c
}

realpath () {
    # prints absolute path of a relative or absolute path
    # sadly POSIX doesn't have this function
    if [ -e "$(dirname "$1")" ]; then
        printf '%s' "$(cd $(dirname $1) && pwd)"/"$(basename $1)"
    else
        error "'$(dirname "$1")' doesn't exist"
        return 1
    fi
}

rreadlink() {
    # source: http://stackoverflow.com/a/29835459
    # Execute the function in a *subshell* to localize variables and the effect of `cd`.
    target=$1 fname= targetDir=
    while true; do # Resolve potential symlinks until the ultimate target is found.
        [ -L "$target" ] || [ -e "$target" ] || return 1
        cd "$(dirname -- "$target")" # Change to target dir; necessary for correct resolution of target path.
        fname=$(basename -- "$target") # Extract filename.
        if [ -L "$fname" ]; then
            # Extract [next] target path, which may be defined
            # *relative* to the symlink's own directory.
            # Note: We parse `ls -l` output to find the symlink target
            #       which is the only POSIX-compliant, albeit somewhat fragile, way,
            target=$(ls -l "$fname")
            target=${target#* -> }
            continue # Resolve [next] symlink target.
        fi
        break # Ultimate target reached.
    done
    targetDir=$(pwd -P) # Get canonical dir. path
    # Output the ultimate target's canonical path.
    printf '%s' "${targetDir}/$fname"
}

backup () {
    if [ -e "$1" ] && [ ! -L "$1" ]; then
        while true; do
            new_file="${1}.$(date "+%Y-%m-%d_%H-%M-%S").backup"
            if [ ! -e "${new_file}" ]; then
                mv "$1" "$new_file" || error "Failed to back up '${1}' to '${new_file}'" && return 1
                warn "Backed up '$1' to '$new_file'"
                return 0
            fi
        done
    else
        return 1
    fi
}

get_flag () {
    printf '%s' " ${1} " | grep " ${2} " > /dev/null && printf '%s' "true" && return 0
    printf '%s' " ${1} " | grep " ${2}! " > /dev/null && printf '%s' "false" && return 0
    if printf '%s' " ${1} " | grep " ${2}=" > /dev/null; then
        printf '%s' " ${1} " | sed 's/.* '${2}'=\([^ ]*\) .*/\1/' && return 0
    fi
    return 1
}

default_flag () {
    if ! get_flag "$1" "$2"> /dev/null; then
        printf "${1} ${2}${3}"
    else
        printf "${1}"
    fi
}

get_git () {
    # Get git repo into a directory
    # Possible configuration flags:
    #   branch: branch name of the repo
    #       default: branch=master
    FLAGS=$(default_flag "$FLAGS" "branch" "=master")
    #   remote: branch name of the repo
    #       default: remote=origin
    FLAGS=$(default_flag "$FLAGS" "remote" "=origin")
    #   backup: if the file already exists back it up otherwise just remove it
    #       default: backup!
    FLAGS=$(default_flag "$FLAGS" "backup" "!")
    #   update: if set and path already exists and is a git repo just pull from origin
    #       default: update
    FLAGS=$(default_flag "$FLAGS" "update" "")
    #   verify_ssl: if set check if cret is valid (usefull for self signed certs)
    #       default: verify_ssl
    FLAGS=$(default_flag "$FLAGS" "verify_ssl" "")
    #   recursive: when cloning a repo use flag --recursive
    #       default: recursive
    FLAGS=$(default_flag "$FLAGS" "recursive" "")
    #   tar_magic: if git is not installed use tar and curl to get remote files (hacky as fuck)
    #       default: tar_magic!
    FLAGS=$(default_flag "$FLAGS" "tar_magic" "!")
    #   force: try to get repo no matter what
    #       default: force!
    FLAGS=$(default_flag "$FLAGS" "force" "!")

    debug "FLAGS: '${FLAGS}'"
    DEST="$(expand_vars "${1}")"
    debug "DEST: '${DEST}'"
    REPO="$(expand_vars "${2}")"
    debug "REPO: '${REPO}'"
    BRANCH="$(get_flag "$FLAGS" 'branch')"
    debug "BRANCH: '${BRANCH}'"
    REMOTE="$(get_flag "$FLAGS" 'remote')"
    debug "REMOTE: '${REMOTE}'"
    if [ "$(get_flag "$FLAGS" 'recursive')" = 'true' ]; then
        RECURSIVE="--recursive"
    else
        RECURSIVE=""
    fi
    debug "RECURSIVE: '${RECURSIVE}'"
    if [ "$(get_flag "$FLAGS" 'verify_ssl')" = 'true' ]; then
        VERIFY_SSL="true"
    else
        VERIFY_SSL="false"
    fi
    debug "VERIFY_SSL: '${VERIFY_SSL}'"

    # force flag is set
    if [ "$(get_flag "$FLAGS" 'force')" = 'true' ]; then
        if ! command -v git > /dev/null; then
            error "git is not installed"
            return 1
        fi
        debug "force flag is set to true. I will do my best to fulfil your wishes master"
        [ "$(get_flag "$FLAGS" 'backup')" = 'true' ] && backup $DEST
        rm -rf "$DEST"
        mkdir -p "$DEST"
        git --config "http.sslVerify=$VERIFY_SSL" clone "$RECURSIVE" --branch "$BRANCH" "$REPO" "$DEST" || \
            (error "Couldn't clone '$REPO' into '$DEST'"; return 1)
    fi
    # if git is not installed fail
    if ! command -v git > /dev/null && [ "$(get_flag "$FLAGS" 'tar_magic')" = 'false' ]; then
        error "git is not installed and tar_magic flag is not set"
        return 1
    fi

    if [ -d "${DEST}/.git" ] && [ "$(get_flag "$FLAGS" 'update')" = 'true' ]; then
        (
        cd "$DEST" || \
            (error "Couldn't \`cd\` into '$DEST'"; return 1)
        git config http.sslVerify "$VERIFY_SSL" || \
            (error "Couldn't set config"; return 1)
        debug "git 'checkout' '$BRANCH'"
        git checkout "$BRANCH" || \
            (error "Couldn't checkout '$BRANCH'"; return 1)
        debug "git 'pull' '$REMOTE' '$BRANCH'"
        git pull "$REMOTE" "$BRANCH" || \
            (error "Couldn't pull '$BRANCH' branch from '$REMOTE'"; return 1)
        if [ "$(get_flag "$FLAGS" 'recursive')" = 'true' ]; then
            debug "git submodule update --init --recursive"
            git submodule update --init --recursive || \
                (error "Couldn't update submodules"; return 1)
        fi
        ) && ok "Pulled successfully"
    else
        [ "$(get_flag "$FLAGS" 'backup')" = 'true' ] && backup $DEST
        rm -rf "$DEST"
        mkdir -p "$DEST"
        if command -v git > /dev/null; then
            debug "git clone --config 'http.sslVerify=$VERIFY_SSL' '$RECURSIVE' --branch '$BRANCH' '$REPO' '$DEST'"
            git clone --config "http.sslVerify=$VERIFY_SSL" "$RECURSIVE" --branch "$BRANCH" "$REPO" "$DEST" || \
                (error "git clone command failed"; return 1)
        else
            error "tar_magic is not implemented yet"
        fi
    fi
}

link () {
    # Creates link from the first arg to second arg
    # Possible configuration flags:
    #   create: if final directory doesn't exist create them recursively
    #       default: create
    FLAGS=$(default_flag "$FLAGS" "create" "")
    #   force: create recursive directories and symlink no matter what
    #       default: force!
    FLAGS=$(default_flag "$FLAGS" "force" "!")
    #   ign_broken: don't care if link will be broke
    #       default: ign_broken
    FLAGS=$(default_flag "$FLAGS" "ign_broken" "!")
    #   backup: if file already exists, back it up
    #       default: backup
    FLAGS=$(default_flag "$FLAGS" "backup" "")
    #   relative: if set target of links will be relative and won't be altered in any way
    #       default: relative!
    FLAGS=$(default_flag "$FLAGS" "relative" "!")

    debug "Flags for link: '$FLAGS'"

    DEST="$(expand_vars "${1}")"
    debug "DEST: '$DEST'"
    # if relative flag set to false expand with BASEDIR else let it raw
    if [ "$(get_flag "$FLAGS" 'relative')" = 'true' ]; then
        SOURCE="$(expand_vars "${2}")"
    elif [ "$(get_flag "$FLAGS" 'relative')" = 'false' ]; then
        SOURCE="$(expand_vars "${BASEDIR}/${2}")"
    else
        error "relative not in '$FLAGS'"
        exit 1
    fi

    debug "SOURCE: '$SOURCE'"

    # check if force flag is set
    if [ "$(get_flag "$FLAGS" 'force')" = 'true' ]; then
        debug "force flag is set to true. I will do my best to fulfil your wishes master"
        [ "$(get_flag "$FLAGS" 'backup')" = 'true' ] && backup $DEST
        rm -rf "$DEST"
        mkdir -p "$(dirname "$DEST")"
        ln -s "$SOURCE" "$DEST" && ok "${DEST} -> ${SOURCE}" || error "${DEST} -> ${SOURCE}"
        return 0
    fi

    # if link will be broken and ign_broken flag is set exit
    if [ "$(get_flag "$FLAGS" 'relative')" = 'false' ]; then
        if [ "$(get_flag "$FLAGS" 'ign_broken')" = 'false' ] && [ ! -e "$SOURCE" ]; then
            warn "'${SOURCE}' doesn't exists. Quiting because ign_broken flag is set"
            return 1
        fi
    elif [ "$(get_flag "$FLAGS" 'relative')" = 'true' ]; then
        warn "If relative flag is set the ign_broken flag is ignored because I can't determinate if the final file exists"
    else
        error "relative not in '$FLAGS'"
    fi

    # if DEST dir doesn't exists and create flag is set, create it
    if [ ! -d "$(dirname "$DEST")" ]; then
        if [ "$(get_flag "$FLAGS" 'create')" = 'true' ]; then
            mkdir -p "$(dirname "$DEST")"
        elif [ "$(get_flag "$FLAGS" 'create')" = 'false' ]; then
            warn "'$(dirname "${DEST}")' doesn't exists. Quiting because create flag is not set"
            return 1
        else
            error "create not in '$FLAGS'"
        fi
    fi

    if [ -L "$DEST" ]; then
        if printf '%s' "$(rreadlink "$DEST")" | grep "^$BASEDIR" > /dev/null; then
            debug "File '${DEST}' exists and it points to my BASEDIR. Replacing it"
            rm "$DEST"
            ln -s "$SOURCE" "$DEST" && ok "${DEST} -> ${SOURCE}" || error "${DEST} -> ${SOURCE}"
        else
            error "'${DEST}' is a link but it's not mine. Quiting"
            return 1
        fi
    elif [ -f "$DEST" ]; then
        [ "$(get_flag "$FLAGS" 'backup')" = 'true' ] && backup $DEST
        ln -s "$SOURCE" "$DEST" && ok "${DEST} -> ${SOURCE}" || error "${DEST} -> ${SOURCE}"
    elif [ -d "$DEST" ]; then
        error "Folder '${DEST}/' in target. I'm afraid. If you set the force flag I'll rip it apart"
        return 1
    elif [ ! -e "$DEST" ]; then
        ln -s "$SOURCE" "$DEST" && ok "${DEST} -> ${SOURCE}" || error "${DEST} -> ${SOURCE}"
    fi
}

shell () {
    # execute an external command
    # Possible configuration flags:
    #   interactive: if set all stds will be redirected to this shell
    #       default: interactive!
    FLAGS=$(default_flag "$FLAGS" "interactive" "!")
    #   stdin: sets the stdin of cmd
    #       default: stdin=
    FLAGS=$(default_flag "$FLAGS" "stdin" "=")
    #   stdout: sets the stdout of cmd
    #       default: stdout=
    FLAGS=$(default_flag "$FLAGS" "stdout" "=")
    #   stderr: sets the stderr of cmd
    #       default: stderr=
    FLAGS=$(default_flag "$FLAGS" "stderr" "=")

    STDIN="$(get_flag "$FLAGS" 'stdin')"
    debug "STDIN: $STDIN"
    STDOUT="$(get_flag "$FLAGS" 'stdout')"
    debug "STDOUT: $STDOUT"
    STDERR="$(get_flag "$FLAGS" 'stderr')"
    debug "STDERR: $STDERR"
    RUN="$1"
    OK=""
    CMD="${2}"

    # add >/dev/null to cmd if stdout flag is not set
    if [ "$(get_flag "$FLAGS" 'interactive')" = 'true' ]; then
        OK="     ${RUN}"
        RUN="${RUN}\n"
        CMD="$CMD > ${STDOUT:-/dev/stdout}"
        CMD="$CMD < ${STDIN:-/dev/tty}"
        CMD="$CMD 2> ${STDERR:-/dev/stderr}"
    elif [ "$(get_flag "$FLAGS" 'interactive')" = 'false' ]; then
        OK=" "
        RUN="${RUN} "
        CMD="$CMD > ${STDOUT:-/dev/null}"
        CMD="$CMD < ${STDIN:-/dev/null}"
        CMD="$CMD 2> ${STDERR:-/dev/null}"
    else
        error "interactive not in '$FLAGS'"
        exit 1
    fi
    debug "COMMAND: $CMD"

    running "$RUN"
    ( eval $CMD ) && ok "$OK" || error "$OK"
}

debug_cmd () {
    FLAGS=$(default_flag "$FLAGS" "true" "")
    FLAGS=$(default_flag "$FLAGS" "false" "!")
    FLAGS=$(default_flag "$FLAGS" "first" "=first")
    FLAGS=$(default_flag "$FLAGS" "second" "=second")
    ok "debug command"
    ok "Flags: '$FLAGS'"
    ARG1="$(expand_vars ${1})"
    ok "Arg1:  '$ARG1'"
    ARG2="$(expand_vars ${2})"
    ok "Arg2:  '$ARG2'"
}

install () {
    COMMAND=''
    OPTIONS=''
    while IFS='' read -r line; do
        # Replace tabs with four spaces
        # FIXME maybe custom this spaces?
        line=$(printf '%s' "$line" | sed "s/\t/    /")
        # Remove comments from lines
        line=$(printf '%s' "$line" | sed 's/#.*$//' | sed 's/^ *$//')
        if [ -z "$line" ]; then
            continue
        fi
        # if printf "$line" | grep '^[[:alpha:]]\+:.*$'
        if [ "$(get_level "$line")" -eq "0" ]; then
            if [ "${line%%:*}" = 'link' ]; then
                COMMAND='link'
                OPTIONS="${line#*:}"
            elif [ "${line%%:*}" = 'shell' ]; then
                COMMAND='shell'
                OPTIONS=${line#*:}
            elif [ "${line%%:*}" = 'get_git' ]; then
                COMMAND='get_git'
                OPTIONS=${line#*:}
            elif [ "${line%%:*}" = 'debug_cmd' ]; then
                COMMAND='debug_cmd'
                OPTIONS=${line#*:}
            else
                COMMAND='error'
                error "'${line%%:*}' command is not one of valid commands"
            fi
        elif [ "$(get_level "$line")" -gt "0" ] && [ "$COMMAND" != "error" ]; then
            #Trim whitespaces
            FST_ARG=$( printf '%s' "${line%%:*}" | sed -e 's/^ *//' -e 's/ *$//')
            SND_ARG=$( printf '%s' "${line#*:}"  | sed -e 's/^ *//' -e 's/ *$//')
            debug "executing FLAGS='${OPTIONS}' '$COMMAND' '$FST_ARG' '$SND_ARG'"
            FLAGS="${OPTIONS}" $COMMAND "$FST_ARG" "$SND_ARG"
        fi
    done < "$CONFIG_FILE"
}

check () {
    if grep "\t" "$CONFIG_FILE" > /dev/null; then
        warn "The config file contains tabs. They will be replaced with 4 spaces"
    fi
}

# main
case "$1" in
    --help)
        show_help
        ;;
    check)
        check
        ;;
    install)
        install
        ;;
    remove)
        error "not implemented yet"
        ;;
    clean)
        error "not implemented yet"
        ;;
    *)
        printf "%s\n" "Try 'install' or '--help'"
        ;;
esac
